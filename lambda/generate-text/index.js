const { BedrockRuntimeClient, InvokeModelCommand } = require('@aws-sdk/client-bedrock-runtime');

const bedrock = new BedrockRuntimeClient({ region: process.env.BEDROCK_REGION || 'us-east-1' });

exports.handler = async (event) => {
  try {
    // Parse request body
    const body = JSON.parse(event.body || '{}');
    const { topic, difficulty } = body;

    if (!topic || !difficulty) {
      throw new Error('Missing topic or difficulty');
    }

    // Validate inputs
    const validTopics = ['daily_life', 'travel', 'technology'];
    const validDifficulties = ['beginner', 'intermediate', 'advanced'];
    if (!validTopics.includes(topic) || !validDifficulties.includes(difficulty)) {
      throw new Error('Invalid topic or difficulty');
    }

    // Craft prompt for Titan Text Express
    const difficultyPrompts = {
      beginner: 'simple sentences with basic vocabulary, 1-2 short sentences (10-15 words total)',
      intermediate: 'moderately complex sentences with common vocabulary, 2-3 sentences (15-25 words total)',
      advanced: 'complex sentences with advanced vocabulary, 2-3 sentences (20-30 words total)'
    };

    const prompt = `Generate text for shadow reading practice on the topic of "${topic.replace('_', ' ')}". The text must be suitable for a ${difficulty} level, using ${difficultyPrompts[difficulty]}. Ensure the text is concise, clear, and appropriate for reading aloud. Avoid lists, dialogue, or overly technical terms unless relevant to the topic. Output only the text content itself, without any introductory phrases, titles, or meta-commentary such as "Here is the text content:". For example, for topic "daily life" and difficulty "beginner", output something like: "I wake up early. I eat breakfast and go to school." End with a period or question mark.`;

    // Prepare payload for Titan Text Express
    const payload = {
      inputText: prompt,
      textGenerationConfig: {
        maxTokenCount: 80,
        stopSequences: [],
        temperature: 0.5,
        topP: 1
      }
    };

    // Invoke Bedrock model
    const command = new InvokeModelCommand({
      contentType: 'application/json',
      body: JSON.stringify(payload),
      modelId: 'amazon.titan-text-express-v1'
    });
    const apiResponse = await bedrock.send(command);

    // Parse response
    const decodedResponseBody = new TextDecoder().decode(apiResponse.body);
    const responseBody = JSON.parse(decodedResponseBody);
    let generatedText = responseBody.results[0]?.outputText?.trim();

    if (!generatedText) {
      throw new Error('No text generated by Bedrock');
    }

    // Clean up unwanted introductory phrases
    generatedText = generatedText
      .replace(/^Here is the text content:?\s*\n*/i, '') // Remove "Here is the text content:"
      .replace(/^Shadow reading practice on the topic of .+:\s*\n*/i, '') // Remove topic-specific intros
      .replace(/^"?\s*/, '') // Remove leading quotes or spaces
      .replace(/"?\s*$/, '') // Remove trailing quotes or spaces
      .replace(/\n+/g, ' ') // Replace newlines with spaces
      .trim(); // Final trim for cleanliness

    // Ensure text ends with a period or question mark
    if (!/[.?!]$/.test(generatedText)) {
      generatedText += '.';
    }

    // Return response
    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: generatedText })
    };
  } catch (error) {
    console.error('Text generation error:', {
      error: error.message,
      stack: error.stack
    });
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ error: 'Failed to generate text: ' + error.message })
    };
  }
};